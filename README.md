# 数据类型
```c
% 取余  /除法


在32 位的系统上
short 占据的内存大小是2 个byte；
int占据的内存大小是4 个byte；
long占据的内存大小是4 个byte；
float占据的内存大小是4 个byte；
double占据的内存大小是8 个byte；
char占据的内存大小是1 个byte。
```
# 静态变量
1.Static 静态局部变量，只被初始化一次，生存期为程序开始到整个程序结束
下次执行这段语句仍是上一次的值
在编译时就需要被赋值，不能使用
# 参数传递
 ![alt text](image.png)
 ![alt text](image-1.png)
 只有通过指针才能改变变量的值
 # 递归
 1、递归表达式
 2、递归的终止条件（出口）：结束递归
 3、递归的深度：由于栈空间有限，即使有出口也可能栈溢出
 # 指针和指针变量
 ![alt text](image-2.png)


 采用用小段存储法


![alt text](image-3.png)


数据类型*指针名  int * p



表示：*表示该变量是指针类型、p存储的为int类型

int *p，q   *号有右结合性，p为指针类型，q为int类型

![alt text](image-4.png)

# 野指针和空指针
![alt text](image-5.png)
#指针的传递
![alt text](image-6.png)
 

如果在函数中交换a和b地址，只是交换的副本的地址。
所以必须在函数副本中交换 a和b副本的指针指向的值

# 数组名和指针
1、数组名就是指针的一种，类似于const指针，不可被赋值，指针是一个变量可以赋值。数组在定义之初就有了自己的内存，当指针未指向一个内存块时，他没有自己的内存
2、数组名是一个代表在内存中起始地址的标识符，在大多数上下文中，数组名可以被视为指向首元素的指针
3、数组名是地址的常量，指针是保存地址的变量


1.数组名在取大小sizeof（）和取地址&情况下不可以视为指针

2.int *p[5]  : 
int(*p)[5] :指向长度为5的int类型数组的指针  
因为 [ ]  的优先级比*解地址的优先级高
![alt text](image-7.png)
# 数组指针和指针数组
![ ](image-8.png)

# 指针常量和常量指针


  常量指针（constant pointer）：
  int * const p=&a
  表示指针本身是一个常量，指针存的是一个地址，指针指向的对象（地址）不可改变
 ![alt text](image-11.png)


指针常量 指向的是一个常量，无法修改指向的内容，但可以指向不同的对象（对象的地址）
  ![alt text](image-10.png)

  # 数组的参数传递

  为什么退化成传递指针？


  1.如果不是传递指针而是数组，就需要吧数组整体拷贝一份，即浪费空间也耗时间


  2.如果传递数组，还要包含数组长度，这太不灵活

  ![alt text](image-12.png)

  所以在数组作为参数传递时 一般化为指针并且要传递数组长度

  例如： 
  int swap(int* arry,int n);
  或int swap(int arry[],int n);表示相同意思
  
   # 宏函数
   ![alt text](image-14.png)
   # 指针的比较
   是地址的比较  
   ![alt text](image-15.png)
# 字符串和字符数组
以字符串打印字符数组，会寻找一个以空字符\0为字符串的结尾

![alt text](image-16.png)
# 字符串变量的初始化
![alt text](image-17.png)
str是一个局部变量数组
# 字符串变量的读写

```c
遍历到字符串末尾的惯用法


char*p=str;
while(*p){
  printf("%c",*p++);
}


puts():用于输出字符串自动添加换行符

scanf：会自动跳过前面的空白字符，录入过程中碰到一个空白字符就结束录入 

gets() ：录入一整行数据
fgets(str,length,stream)
代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据stdin表示并在结尾加上\n和\0
```
# c语言的字符串库
#<string.h>
```c
1.strlen(str)
计算从str首地址到\0的长度
2.char*strcpy(char*dest,const char *src,size)
至多将n个字符从src中复制到dest
strncpy（a,b,n）将b中至多n个字符从src中复制到dest中
3.char strcat (char dest,char *src);
函数功能：将两个字符串连接合并成一个字符串，也就是把字符串src连接到字符串dest后面，连接后的结果放在字符串dest中
返回值：指向字符串dest的指针
strncmp(a,b,n)
4.int strcmp (char str1,char str2);
函数功能：比较两个字符串的大小，也就是把字符串str1和字符串str2从首字符开始逐字符的进行比较，直到某个字符不相同或比较到最后一个字符为止，字符的比较为ASIC码的比较
返回值：若字符串str1大于字符串str2返回结果大于零，若字符串str1小于字符串str2返回结果小于零，若字符串str1等于字符串str2返回结果等于零
strncmp(a,b,n)
```
# 字符串数组
```c
1.字符串数组
char week_day[][10]={"Monday,"Tuesday","THURSDAY"};

2.字符指针数组
 char*p[5]={"az","ac"}
 ```

![alt text](image-20.png)

# 命令行传参
```c
#include <stdio.h>

int main( int argc, char *argv[] ){ //argc与argv[][],argv也可采用char **argv的格式
   return 0;
}
```
# 结构体

不同类型的数据聚合到统一的结构中 

 
1. 结构体与cpp对象的区别
![alt text](image-21.png)
   

2. 结构体的定义结构


     ![alt text](image-22.png)


       可以在main 函数之前定义类似于函数声明


3. 结构体的初始化     struct student_s  s1={.......};
```c
typedef struct student_s {
       int* elements; 
       int size;	
       int capacity; 
   } Vector;
   使用typedef 将该结构体定义别名为Vector,在后面赋值时就不用像上面一样  

   可以直接 Vector s1.elements=&a;
   ```
   4. 结构体的对齐填充
   ![alt text](image-23.png)
   5. 数组和结构体的不同点

    结构体可以相互赋值，只要为同一类型的结构体，但数组不可以

     结构体和指针完全没有关系，结构体本身就是一种数据类型，结构体的名字相当于int。

  6. 结构体指针类型

    int *p 类比 Vector *p  对应(*p).size

    上述代码太丑 ->相当于(*p).  p->size

  7. 结构体的传递与传递
   
    会复制一个副本，只有通过指针才能修改
    student.chinese=200 错误
    p->chinese=200 可以修改成功 

    使用复制库函数去修改结构体的参数

    strncpy(p->name."liuziyuan",sizeof(p->name-1))
# 枚举
![alt text](image-24.png)
性质:枚举类型是一种自定义的复合数据类型，由一组可命名的整数常量组成。每个枚举成员都对应一个整数值，可以通过成员的名称来直接引用这些整数值。
 

    enum typeName { valueName1, valueName2, valueName3, ...... }变量1，变量2;
    enum DAY{MON=1, TUE, WED, THU, FRI, SAT, SUN};


(1)typeName是枚举类型的名字，花括号里面的元素（枚举成员）是常量而不是变量，这个一定要搞清楚，因为枚举成员的是常量，所以不能对它们赋值，只能将它们的值赋给其他的变量。

(2)宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。

 (3)第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。在当前值没有赋值的情况下，枚举类型的当前值总是前一个值+1.

(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。

(5) 枚举型是预处理指令#define的替代。

(6) 类型定义以分号;结束。

(7)emum定义变量类似于结构体，要么在分号前，要么使用 enum DAY s1;
   ```c
      typedef enum
    { wednesday,thursday,friday} 
      workday;
```
2. 定义方式

```c
  1、先定义枚举类型，再定义枚举变量
enum DAY
{
MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;

2、定义枚举类型的同时定义枚举变量
enum DAY
{
MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;


3、省略枚举名称，直接定义枚举变量
enum
{
MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

# 堆和栈

1. 存储期限



![alt text](image-25.png)

内存中低地址为首位，pc

![alt text](image-26.png)
```c

栈区内存管理机制的优点:
1.简单高效

2.自动管理,程序员不需要干涉

3.进程/线程, 一个线程就是进程中的一条执行路径,子任务执行路径: 就是一条函数调用链
所以栈区是线程私有的,每个线程都有自己独立的栈区
这样的优点是: 线程隔离安全 不需要考虑线程的安全问题

缺点:
1.栈区的管理仅仅通过SP的加加减减完成,虽然很简单,但是也带来副作用：就是每个函数栈帧的大小,在编译时期就是要确定的
-->
意味着栈区的所有数据变量的大小也必须在编译时期确定。所以栈区数组的长度必须编译时确定栈区的数据不能在运行时期动态的确定大小

2.线程间无法交换共享栈区数据
3.栈区的大小很有限.一般只有几Mb 栈区是不能存放大数组,大结构体的
```
```c
堆区的内存管理完全不同于栈区简单高效、自动的内存管理，堆区的内存管理主要由程序员调用内存分配函数
(如malloc、free等)来手动进行分配、释放管理。
你可以认为堆区的内存管理是依赖程序员手动完成的。
  

堆区域的内存管理有以下优点：
1. 很大。虽然堆区域的大小仍受限于计算机实际可用内存的大小，但堆区域要远大于栈。堆区域可以存放很大的数据。

2. 在多线程环境中，进程中的所有线程共享同一个的堆空间，便于实现线程间的数据共享。

3.***   动态内存分配。堆内存可以在程序运行时动态分配和释放，可以用于存储动态分配内存空间的数据。

4. 生命周期更灵活。程序员可以手动决定堆中数据的存活与销毁，堆中数据具有动态存储期限。
优点几乎是栈区缺点反过来，当然缺点也几乎是栈区优点反过来：
缺点：
1. 管理繁琐且不安全。C程序把内存管理这么重要的事情交给程序员，充分信任程序员，但实际上很多时候程序员(尤其是初学者)无法很好的管理内存，这会为程序带来很大的安全隐患。

2. 性能问题。动态内存分配和回收的开销比栈操作大，可能影响程序性能。(动态分配过程会涉及系统调用，
严重影响程序的性能)

3. 线程不安全。多个线程共享同一个堆，就必须考虑安全问题(需要实现线程同步，加锁)。这一方面引入了复
杂性，另一方面也会导致性能下降
```
# 通用指针void*

![alt text](image-27.png)
```c
0. 强制类型转换:
格式为：



(类型名) （表达式） 或者 （类型名） 表达式

(int)(x+y)     或者(int)x+y

```

```c
1. 通用指针类型(void*类型指针)
   

通用指针可以用来存放任意型的内存地址，char、short、int、float、double等这些类型的地址都可以使用void *型变量来存放。同样char *、short *、int *、float *、double *等指针变量均可以赋值给void *型变量

**************************************
通用指针与普通指针的唯一区别是：通用指针无法解引用
**************************************

   若通用指针想要解引用。必须要对其强制类型转换为指定类型指针，再对其解引用
   例：
#include <stdio.h>
int main(int argc, char **args)
{
        int i = 0x11223344;
        void *p = &i;
        *(char *)p = 0;
        p+=2;
        *(char *)p = 0;
 
        printf("0x%x\n", i);
}
 运行结果：

0x11003300

分析：首先(char *)p就是将通用指针强制转换为char *类型，也就是告诉编译器这是一个指向char型的指针变量，然后再对其解引用*(char *)p，把这个地址中的变量赋值为0。由于编译器认为这是一个char型指针，所以*(char *)p只为地址为0x2000的内存byte赋值。接下来p += 2;表示p的值加2，于是p的值为0x2002，然后同样将其强转为char型指针，再对其解引用并赋值。于是内存中0x2002处的值就被赋值成了0。最后使用printf函数来显示i的值为0x11003300，运行结果正确。

即0x2000和0x2002都被赋值为0
```
小端存储法
![alt text](image-29.png)

虽然void *p这样的通用指针不能解引用，但是void **p这样的二级指针却可以解引用：
```c
int main(int argc, char **args)
{
        int i = 7;
        void *p1 = &i;
        void **p2 = &p1;
 
        printf("0x%x\n", *p2);
}


 上面代码的合法的，运行结果为：

0xffc68d28

解释：void *p1是一个通用指针，编译无法知道p1所指向的地址是一个什么类型的变量，而对于void **p2而言，编译器知道p2是一个指针，这个指针变量中存放的是一个通用型指针的地址也就是&p1，因为&p1是一个地址，在32位架构下所有指针变量以及内存地址都占用4byte（32bit），所以对p2解引用*p2是合法的，它代表的是一个void *型变量的地址即&p1，它的值是0xffc68d28。
```
# 动态内存分配和释放 malloc
```c
函数声明：void*malloc(size)

作用：在堆中分配出一块连续的size字节大小的内存块，该内存块中的数据是随机未定义的，并返回该内存块的首字节地址（void*）。

若分配失败返回空指针（null）所以在使用malloc时一定要规范，判NULL

并且在接收时候赋值需要强制类型转换

例：int* result = (int*)malloc(2 * sizeof(int));

1.malloc内存大小：2 * sizeof(int) 计算了要分配的内存大小。 2 * sizeof(int) 表示要分配的内存大小为两个整数占用的字节数

2.：使用 malloc 分配的内存要在不使用时手动释放，以避免内存泄漏，用 free(result) 来释放 result 指向的内存。所以将其拆解看为分配内存加强制转换指针类型。
```
当分配内存后，未能适时释放会导致内存泄漏。使内存在程序的生命周期无法重复被使用。
# 动态内存分配和释放 free 
```c
头文件在<stdlib.h>
free()函数的功能是:释放以前由 malloc(),calloc(),realloc()函数动态开辟的内存空间.使其可以重新被分配.
在使用free（p） 之后将指针p置为NULL,防止其变成野指针
void free (void* ptr);
该参数的类型是无类型指针(void*),它指向先前由malloc(),calloc(),realloc()动态分配的内存块,它的作用是告诉函数要释放的内存块的起始位置.
```
# malloc 和free 常见使用模板
```c
int* p = (int*)malloc(sizeof(int)*10);    //开辟10个整型大小空间
    if (p == NULL)       //如果开辟失败,则打印错误原因
    {
        
        printf("%s\n", strerror(errno));//打印错误原因
    }
    else
    {   
      （分配空间的目的语句）
    }
 free(p);    //释放p的内存空间
    p = NULL;         //将指针p置为NULL,防止其变成野指针
```
# callloc 清零内存分配函数和realloc扩容分配函数
```c
calloc函数例如：
int* ptr = (int*)calloc(10, sizeof(int));

分配内存空间时会自动初始化0值，它需要两个参数，即要分配的元素个数和每个元素的大小。如果分配成功，返回指向分配内存的指针；如果分配失败，返回NULL。


realloc：realloc函数用于重新调整之前用malloc或calloc分配的内存空间的大小。它需要两个参数
1. 若新内存比旧内存小，会在旧内存尾部截断
2.新>旧 会尽可能尝试原地扩大，若无法扩大会在别处申请空间分配内存，并将旧内存块中的数据全部复制进去，将旧内存自动释放

如果调整成功，返回指向重新调整后的内存的指针；如果调整失败，返回NULL。

例如：int* new_ptr = (int*)realloc(ptr, 20 * sizeof(int));
```
![alt text](image-30.png)

# 手动实现c语言中的Vector
背景：在C语言中，传统的数组(指在栈上分配内存空间的数组)拥有一个显著的限制：它们的长度一旦确定便无法更改。这在处理动态数据集时显得尤为不便，如在不确定数据量的情况下存储用户输入。

C++通过引入Vector这样的动态数组解决了这个问题(Java中的ArrayList也是类似的)，它可以根据需要动态调整大小。遗憾的是，C语言标准库中并未提供类似的结构。但不要担心，借助于动态内存分配函数如malloc和realloc，我们完全可以在C中手动实现类似的功能。
```c
在C语言中实现一个动态数组，通常使用一个结构体定义,即结构体中包含指向一个动态分配的指针和这个动态数组的数量和容量
typedef int ElementType;

typedef struct {
    ElementType *data;      // 指向动态分配数组的指针
    int size;    // 当前动态数组中元素的数量
    int capacity; // 动态数组当前分配的最大容量
} Vector;
```
![alt text](image-31.png)

# 头文件保护以及函数声明
头文件主要用于存放以下结构：

函数的声明
结构体的定义
类型别名的定义
宏定义
...
头文件允许程序员在多个源文件之间共享函数的声明以及结构体、类型别名和宏的定义
防止头文件被重复包含
```c
#ifndef __A_H  //检查宏 __A_H 是否未被定义
#define __A_H  //如果 __A_H没有被定义，则定义它，并继续执行后面的代码。

写函数声明

#endif // __A_H


比如说第二次包含时，就会直接跳转到endif

使用<>尖括号时，编译器只在标准库头文件的路径中搜索头文件。它不会在当前文件的目录中查找。

当使用双引号""时，编译器首先在当前文件的目录中搜索头文件

```
# 链表
![alt text](image-32.png)
```c
链表的概念:链表是C语言常用的一种数据结构，可以把它理解成为一个包含数据和指针的结构体，链表中除了最后一个数据外，每个链表元素的指针都指向下一个链表元素的地址
链表的基本用法：
1.直接定义
  struct node {
		int data;
		struct node* next;
	};

2. 利用typedef定义一个类型
typedef struct node {
	int data;
	struct node  *next;  //struct node 是一个数据类型 表示指向的是一个
} Node;
3.由于链表本身是一个结构体，我们遍历时只需要获得链表的数据即可，我们可以定义一个结构体指针来帮助我们完成

    Node* p = header.next;
	while (p != NULL) 
	{
		printf("%d\n",p->data);
		p=p->next;
	}
```
# 头插法进行链表节点的创建
```c
头插法，指的是：
1先创建一个新结点。
2然后将新结点的next指针指向原本的第一个结点
3更新头指针，使其指向新创建的结点。
具体而言，又可分为两种情况：

头插法插入整个链表的第一个结点。
头插法插入链表随后的结点，即整条链表只有一个头节点指向null

具体代码见文件
```
  # 点号（.）和箭头（->）的区别

  点号（.）通过结构体变量访问成员变量
	箭头符号（->）通过（结构体） 指针 访问成员变量

  # 二级指针
  C语言函数传参的规律特点：

直接传递变量值：用于读取数据，不修改原始变量。
传递一级指针：可以修改指针指向的数据，但不能改变指针自身。
传递二级指针：可以修改一级指针的指向，或者一级指针指向的数据。

  二级指针
  即可以完成类似指针的作用，修改指针。比如说函数传入指针时不能改变指针自身，但使用二级指针就可以改变地址。
  # 函数指针
  函数返回值类型 (*函数指针名)(函数形参列表);
  ```c
  // 声明一个指向"返回值类型是void、不接受任何参数的函数"的指针
void (*fun_ptr)(void);

// 声明一个指向"返回值类型是int、接受两个int参数的函数"的指针
int (*fun_ptr2)(int, int);

// 声明一个指向"返回值类型是char指针、接受一个const char指针参数的函数"的指针
char* (*fun_ptr3)(const char *);

```
```c
给函数指针类型起别名（注意是对指针类型起别名）

typedef 函数返回值类型 (*函数指针别名)(函数形参列表);

// 一个指向"返回值类型是void、不接受任何参数的函数"的指针类型,别名是FuncPtr
typedef void (*FuncPtr)(void);

// 函数指针类型作为形参
//void test(void p(void)) 函数原型，即用Funcptr代表函数的指针类型，p表示函数实际的名字
void test(FuncPtr p){
}
void main(void){
    // 声明函数指针类型指针变量
    FuncPtr p;
    return 0;
}
```
# qsort
```c
C语言中的qsort 函数是一个功能强大的标准库函数，调用它需要包含头文件<stdlib.h>。

正如它的函数名一样，它的作用是进行排序，而由于在函数内部采用快速排序算法(quick sort)，所以它被命名为"qsort"。

该函数的声明是：
void qsort(void *base, size_t num, size_t size, int (*compare)(const void *, const void *));
函数的每一个参数意为：

base：通用指针类型，表示要排序的数组，可以是任意类型数组。
num：数组中的元素数量，也就是待排序的base数组的长度。
size：base数组中每个元素的大小，通常使用 sizeof 运算符得到。
compare：函数指针类型，表示该函数需要传入一个返回值类型是int，形参列表是const void *, const void *的
表示比较规则的函数。

qsort函数的行为，需要的有两个规则：

1.排序的规则：qsort函数会将base数组中的元素按照 从小到大 的顺序排序，这个排序的规则是固定的。
2. 比较大小的规则：既然是按照从小到大排序，那么如何决定数组中元素的大小关系呢？答：由函数指针传入的函数决定！
```
```c
int any_name(const void *a, const void *b);
这个函数用来表示内部排序的比较逻辑

两个参数表示所要比较元素的地址，之所以参数的接收类型为 void* 是因为比较元素的类型是不清楚的，只能以 void* 这个万能桶进行接收；const表示指针所指向元素的值无法更改。`
返回值整数代码a和b的大小关系，实际上可以把该函数看出"(a - b)"：

如果返回值小于0是个负数，说明a < b
如果返回值大于0是个正数，说明a > b
如果返回值是0，说明a = b

例如：一级排序
// qsort函数会将学生数组按照学号,从小到大排序
// 该比较规则认为: 学号越小,学生越小
int cmp(const void* a, const void* b) {
    // void指针需要类型转换后才能使用
    Student* s1 = (Student*)a;  
    Student* s2 = (Student*)b;

    return (s1->stu_id) - (s2->stu_id);
}
qsort(stus, len, sizeof(Student), my_cmp);     // 按照my_cmp3函数的比较规则从小到大排序
二级排序：若名字相同则按照成绩再进行排序
int cmp_s(const void* elem1, const void* elem2)
{
	if ((strcmp(((Stu*)elem1)->name, ((Stu*)elem2)->name))!=0)
		return strcmp(((Stu*)elem1)->name, ((Stu*)elem2)->name);
	else
		return ((Stu*)elem1)->grade - ((Stu*)elem2)->grade;
}


